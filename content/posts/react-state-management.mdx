---
title: "Reactの状態管理パターン"
date: "2025-01-03"
category: "React"
tags: ["React", "状態管理"]
description: "useStateからuseReducerまで、Reactの状態管理の基本を理解します。"
published: true
---

## 状態管理とは

Reactアプリケーションにおいて、状態（State）はコンポーネントのデータを管理する重要な概念です。適切な状態管理により、インタラクティブなUIを実現できます。

## useState - シンプルな状態管理

最も基本的な状態管理フックです。

```jsx
import { useState } from 'react'

function Counter() {
  const [count, setCount] = useState(0)

  return (
    <div>
      <p>カウント: {count}</p>
      <button onClick={() => setCount(count + 1)}>
        増加
      </button>
    </div>
  )
}
```

### 複数の状態を管理

```jsx
function UserForm() {
  const [name, setName] = useState('')
  const [email, setEmail] = useState('')
  const [age, setAge] = useState(0)

  // または、オブジェクトとして管理
  const [user, setUser] = useState({
    name: '',
    email: '',
    age: 0
  })

  const updateUser = (field, value) => {
    setUser(prev => ({
      ...prev,
      [field]: value
    }))
  }
}
```

## useReducer - 複雑な状態管理

複数の値を持つ状態や、複雑なロジックが必要な場合に有効です。

```jsx
import { useReducer } from 'react'

const initialState = {
  count: 0,
  history: []
}

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return {
        count: state.count + 1,
        history: [...state.history, state.count + 1]
      }
    case 'decrement':
      return {
        count: state.count - 1,
        history: [...state.history, state.count - 1]
      }
    case 'reset':
      return initialState
    default:
      throw new Error('Unknown action type')
  }
}

function ComplexCounter() {
  const [state, dispatch] = useReducer(reducer, initialState)

  return (
    <div>
      <p>現在の値: {state.count}</p>
      <p>履歴: {state.history.join(', ')}</p>
      <button onClick={() => dispatch({ type: 'increment' })}>+</button>
      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>
      <button onClick={() => dispatch({ type: 'reset' })}>リセット</button>
    </div>
  )
}
```

## Context API - グローバル状態管理

プロップスドリリングを避けるために、Context APIを使用します。

```jsx
import { createContext, useContext, useState } from 'react'

// 1. Contextを作成
const ThemeContext = createContext()

// 2. Providerコンポーネント
export function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light')

  const toggleTheme = () => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light')
  }

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  )
}

// 3. カスタムフック
export function useTheme() {
  const context = useContext(ThemeContext)
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider')
  }
  return context
}

// 4. 使用例
function ThemedButton() {
  const { theme, toggleTheme } = useTheme()

  return (
    <button
      onClick={toggleTheme}
      style={{
        background: theme === 'light' ? '#fff' : '#333',
        color: theme === 'light' ? '#333' : '#fff'
      }}
    >
      テーマ切り替え
    </button>
  )
}
```

## カスタムフック

状態ロジックを再利用可能にするため、カスタムフックを作成します。

```jsx
function useLocalStorage(key, initialValue) {
  const [storedValue, setStoredValue] = useState(() => {
    try {
      const item = window.localStorage.getItem(key)
      return item ? JSON.parse(item) : initialValue
    } catch (error) {
      console.log(error)
      return initialValue
    }
  })

  const setValue = (value) => {
    try {
      setStoredValue(value)
      window.localStorage.setItem(key, JSON.stringify(value))
    } catch (error) {
      console.log(error)
    }
  }

  return [storedValue, setValue]
}

// 使用例
function Settings() {
  const [settings, setSettings] = useLocalStorage('app-settings', {
    darkMode: false,
    language: 'ja'
  })

  return (
    <div>
      <label>
        <input
          type="checkbox"
          checked={settings.darkMode}
          onChange={(e) => setSettings({
            ...settings,
            darkMode: e.target.checked
          })}
        />
        ダークモード
      </label>
    </div>
  )
}
```

## まとめ

適切な状態管理手法を選択することで、保守性が高く、パフォーマンスの良いReactアプリケーションを構築できます。シンプルな状態にはuseState、複雑なロジックにはuseReducer、グローバル状態にはContext APIを使い分けましょう。